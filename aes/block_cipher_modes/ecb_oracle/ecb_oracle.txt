

ciphertext is 32 bytes long

key exploits: 

the key encrypting the 16 byte string 

00000000000000000000000000000000 to eb4df1b90bfec46fedb8d6e8281dccb4

is the same key encrypting each 16 byte segment of the plaintext

let plaintext_1 be the first half of the plaintext

plaintext_2 be the other

plaintext_1 -> 070d0fecb63af7457ac4fc08d1fea854

plaintext_2 -> 644a8fdb2da6844de4338052cc56d24d

========================================================================================

encrypting 'crypto{aaaaaaaa}' (16 bytes long) -> 26e48f6193dd4f06ed7d0bf6322df12f

encrypting the first 16 bytes of the flag -> 070d0fecb63af7457ac4fc08d1fea854

encrypting the second 16 bytes of the flag -> 644a8fdb2da6844de4338052cc56d24d

==========================================================================================

i can brute force the first block of plaintext as follows:

to get the first character, prepend the input by 15 bytes of known plaintext.

after encrypting,
the first 16 bytes will be the encrpytion of:

xxxxxxxxxxxxxxc

where the x's are known bytes and c is unknown.

but there are only 255 possibilities for c : easily brute forceable

then i can prepend the input by 14 characters.

after encrypting,
the first 16 bytes will be the encryption of

xxxxxxxxxxxxxyc

y being the c in the previous round, now known, 
and the last character is again unknown. again, i can brute force y, since there are only 255 possibilities.

i can repeat this and recover the entire first block of the ciphertext.

Decrypting the second block is a modification of decrypting the first block.


plaintext is:

crypto{p3n6u1n5_
h473_3cb}

(the first line is from the first block of the ciphertext. the second line is from the second block. note that the entire plaintext is not two blocks though. it is only 26 bytes long.






